//
// Generated by Bluespec Compiler, version 2012.01.A (build 26572, 2012-01-17)
//
// On Thu Jan  2 11:49:46 GMT 2014
//
// Method conflict info:
// Method: fsl_in_put
// Conflict-free: fsl_out_get
// Conflicts: fsl_in_put
//
// Method: fsl_out_get
// Conflict-free: fsl_in_put
// Conflicts: fsl_out_get
//
//
// Ports:
// Name                         I/O  size props
// RDY_fsl_in_put                 O     1 reg
// fsl_out_get                    O    32 reg
// RDY_fsl_out_get                O     1 reg
// CLK                            I     1 clock
// RST_N                          I     1 reset
// fsl_in_put                     I    32 reg
// EN_fsl_in_put                  I     1
// EN_fsl_out_get                 I     1
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
`define BSV_ASSIGNMENT_DELAY
`endif

module mkBootPattern(CLK,
		     RST_N,

		     fsl_in_put,
		     EN_fsl_in_put,
		     RDY_fsl_in_put,

		     EN_fsl_out_get,
		     fsl_out_get,
		     RDY_fsl_out_get);
  input  CLK;
  input  RST_N;

  // action method fsl_in_put
  input  [31 : 0] fsl_in_put;
  input  EN_fsl_in_put;
  output RDY_fsl_in_put;

  // actionvalue method fsl_out_get
  input  EN_fsl_out_get;
  output [31 : 0] fsl_out_get;
  output RDY_fsl_out_get;

  // signals for module outputs
  wire [31 : 0] fsl_out_get;
  wire RDY_fsl_in_put, RDY_fsl_out_get;

  // inlined wires
  wire fetcher_fsm_start_wire$whas, fetcher_fsm_state_set_pw$whas;

  // register address
  reg [7 : 0] address;
  wire [7 : 0] address$D_IN;
  wire address$EN;

  // register booting
  reg booting;
  wire booting$D_IN, booting$EN;

  // register fetcher_fsm_start_reg
  reg fetcher_fsm_start_reg;
  wire fetcher_fsm_start_reg$D_IN, fetcher_fsm_start_reg$EN;

  // register fetcher_fsm_start_reg_1
  reg fetcher_fsm_start_reg_1;
  wire fetcher_fsm_start_reg_1$D_IN, fetcher_fsm_start_reg_1$EN;

  // register fetcher_fsm_state_can_overlap
  reg fetcher_fsm_state_can_overlap;
  wire fetcher_fsm_state_can_overlap$D_IN, fetcher_fsm_state_can_overlap$EN;

  // register fetcher_fsm_state_fired
  reg fetcher_fsm_state_fired;
  wire fetcher_fsm_state_fired$D_IN, fetcher_fsm_state_fired$EN;

  // register fetcher_fsm_state_mkFSMstate
  reg [2 : 0] fetcher_fsm_state_mkFSMstate;
  reg [2 : 0] fetcher_fsm_state_mkFSMstate$D_IN;
  wire fetcher_fsm_state_mkFSMstate$EN;

  // ports of submodule fsl_in_fifo
  wire [31 : 0] fsl_in_fifo$D_IN, fsl_in_fifo$D_OUT;
  wire fsl_in_fifo$CLR,
       fsl_in_fifo$DEQ,
       fsl_in_fifo$EMPTY_N,
       fsl_in_fifo$ENQ,
       fsl_in_fifo$FULL_N;

  // ports of submodule fsl_out_fifo
  wire [31 : 0] fsl_out_fifo$D_IN, fsl_out_fifo$D_OUT;
  wire fsl_out_fifo$CLR,
       fsl_out_fifo$DEQ,
       fsl_out_fifo$EMPTY_N,
       fsl_out_fifo$ENQ,
       fsl_out_fifo$FULL_N;

  // ports of submodule rom
  wire [33 : 0] rom$DATA;
  wire [7 : 0] rom$ADDR;
  wire rom$EN;

  // rule scheduling signals
  wire WILL_FIRE_RL_fetcher_fsm_action_l54c9,
       WILL_FIRE_RL_fetcher_fsm_action_l58c25,
       WILL_FIRE_RL_fetcher_fsm_action_l78c22,
       WILL_FIRE_RL_fetcher_fsm_fsm_start;

  // inputs to muxes for submodule ports
  wire MUX_fsl_out_fifo$enq_1__SEL_1;

  // remaining internal signals
  wire fetcher_fsm_abort_whas_AND_fetcher_fsm_abort_w_ETC___d70;

  // action method fsl_in_put
  assign RDY_fsl_in_put = fsl_in_fifo$FULL_N ;

  // actionvalue method fsl_out_get
  assign fsl_out_get = fsl_out_fifo$D_OUT ;
  assign RDY_fsl_out_get = fsl_out_fifo$EMPTY_N ;

  // submodule fsl_in_fifo
  FIFO2 #(.width(32'd32), .guarded(32'd1)) fsl_in_fifo(.RST_N(RST_N),
						       .CLK(CLK),
						       .D_IN(fsl_in_fifo$D_IN),
						       .ENQ(fsl_in_fifo$ENQ),
						       .DEQ(fsl_in_fifo$DEQ),
						       .CLR(fsl_in_fifo$CLR),
						       .D_OUT(fsl_in_fifo$D_OUT),
						       .FULL_N(fsl_in_fifo$FULL_N),
						       .EMPTY_N(fsl_in_fifo$EMPTY_N));

  // submodule fsl_out_fifo
  FIFO2 #(.width(32'd32), .guarded(32'd1)) fsl_out_fifo(.RST_N(RST_N),
							.CLK(CLK),
							.D_IN(fsl_out_fifo$D_IN),
							.ENQ(fsl_out_fifo$ENQ),
							.DEQ(fsl_out_fifo$DEQ),
							.CLR(fsl_out_fifo$CLR),
							.D_OUT(fsl_out_fifo$D_OUT),
							.FULL_N(fsl_out_fifo$FULL_N),
							.EMPTY_N(fsl_out_fifo$EMPTY_N));

  // submodule rom
  wr_pattern rom(.clk(CLK),
		 .rst_n(RST_N),
		 .ADDR(rom$ADDR),
		 .EN(rom$EN),
		 .DATA(rom$DATA));

  // rule RL_fetcher_fsm_action_l58c25
  assign WILL_FIRE_RL_fetcher_fsm_action_l58c25 =
	     (rom$DATA[33:32] != 2'h1 || fsl_out_fifo$FULL_N) && booting &&
	     (fetcher_fsm_state_mkFSMstate == 3'd1 ||
	      fetcher_fsm_state_mkFSMstate == 3'd2) ;

  // rule RL_fetcher_fsm_fsm_start
  assign WILL_FIRE_RL_fetcher_fsm_fsm_start =
	     fetcher_fsm_abort_whas_AND_fetcher_fsm_abort_w_ETC___d70 &&
	     fetcher_fsm_start_reg ;

  // rule RL_fetcher_fsm_action_l54c9
  assign WILL_FIRE_RL_fetcher_fsm_action_l54c9 =
	     fetcher_fsm_start_wire$whas &&
	     fetcher_fsm_state_mkFSMstate == 3'd0 ;

  // rule RL_fetcher_fsm_action_l78c22
  assign WILL_FIRE_RL_fetcher_fsm_action_l78c22 =
	     fsl_out_fifo$FULL_N && fsl_in_fifo$EMPTY_N &&
	     (!booting &&
	      (fetcher_fsm_state_mkFSMstate == 3'd1 ||
	       fetcher_fsm_state_mkFSMstate == 3'd2) ||
	      fetcher_fsm_state_mkFSMstate == 3'd3) ;

  // inputs to muxes for submodule ports
  assign MUX_fsl_out_fifo$enq_1__SEL_1 =
	     WILL_FIRE_RL_fetcher_fsm_action_l58c25 &&
	     rom$DATA[33:32] == 2'h1 ;

  // inlined wires
  assign fetcher_fsm_start_wire$whas =
	     WILL_FIRE_RL_fetcher_fsm_fsm_start ||
	     fetcher_fsm_start_reg_1 && !fetcher_fsm_state_fired ;
  assign fetcher_fsm_state_set_pw$whas =
	     WILL_FIRE_RL_fetcher_fsm_action_l78c22 ||
	     WILL_FIRE_RL_fetcher_fsm_action_l58c25 ||
	     WILL_FIRE_RL_fetcher_fsm_action_l54c9 ;

  // register address
  assign address$D_IN = address + 8'd1 ;
  assign address$EN =
	     WILL_FIRE_RL_fetcher_fsm_action_l58c25 ||
	     WILL_FIRE_RL_fetcher_fsm_action_l54c9 ;

  // register booting
  assign booting$D_IN = 1'd0 ;
  assign booting$EN =
	     WILL_FIRE_RL_fetcher_fsm_action_l58c25 &&
	     rom$DATA[33:32] != 2'h1 &&
	     rom$DATA[33:32] != 2'h2 &&
	     rom$DATA[33:32] != 2'h3 ;

  // register fetcher_fsm_start_reg
  assign fetcher_fsm_start_reg$D_IN = !WILL_FIRE_RL_fetcher_fsm_fsm_start ;
  assign fetcher_fsm_start_reg$EN =
	     WILL_FIRE_RL_fetcher_fsm_fsm_start ||
	     fetcher_fsm_abort_whas_AND_fetcher_fsm_abort_w_ETC___d70 &&
	     !fetcher_fsm_start_reg ;

  // register fetcher_fsm_start_reg_1
  assign fetcher_fsm_start_reg_1$D_IN = fetcher_fsm_start_wire$whas ;
  assign fetcher_fsm_start_reg_1$EN = 1'd1 ;

  // register fetcher_fsm_state_can_overlap
  assign fetcher_fsm_state_can_overlap$D_IN =
	     fetcher_fsm_state_set_pw$whas || fetcher_fsm_state_can_overlap ;
  assign fetcher_fsm_state_can_overlap$EN = 1'd1 ;

  // register fetcher_fsm_state_fired
  assign fetcher_fsm_state_fired$D_IN = fetcher_fsm_state_set_pw$whas ;
  assign fetcher_fsm_state_fired$EN = 1'd1 ;

  // register fetcher_fsm_state_mkFSMstate
  always@(WILL_FIRE_RL_fetcher_fsm_action_l54c9 or
	  WILL_FIRE_RL_fetcher_fsm_action_l58c25 or
	  WILL_FIRE_RL_fetcher_fsm_action_l78c22)
  begin
    case (1'b1) // synopsys parallel_case
      WILL_FIRE_RL_fetcher_fsm_action_l54c9:
	  fetcher_fsm_state_mkFSMstate$D_IN = 3'd1;
      WILL_FIRE_RL_fetcher_fsm_action_l58c25:
	  fetcher_fsm_state_mkFSMstate$D_IN = 3'd2;
      WILL_FIRE_RL_fetcher_fsm_action_l78c22:
	  fetcher_fsm_state_mkFSMstate$D_IN = 3'd3;
      default: fetcher_fsm_state_mkFSMstate$D_IN =
		   3'bxxx /* unspecified value */ ;
    endcase
  end
  assign fetcher_fsm_state_mkFSMstate$EN =
	     WILL_FIRE_RL_fetcher_fsm_action_l54c9 ||
	     WILL_FIRE_RL_fetcher_fsm_action_l58c25 ||
	     WILL_FIRE_RL_fetcher_fsm_action_l78c22 ;

  // submodule fsl_in_fifo
  assign fsl_in_fifo$D_IN = fsl_in_put ;
  assign fsl_in_fifo$ENQ = EN_fsl_in_put ;
  assign fsl_in_fifo$DEQ = WILL_FIRE_RL_fetcher_fsm_action_l78c22 ;
  assign fsl_in_fifo$CLR = 1'b0 ;

  // submodule fsl_out_fifo
  assign fsl_out_fifo$D_IN =
	     MUX_fsl_out_fifo$enq_1__SEL_1 ?
	       rom$DATA[31:0] :
	       fsl_in_fifo$D_OUT ;
  assign fsl_out_fifo$ENQ =
	     WILL_FIRE_RL_fetcher_fsm_action_l58c25 &&
	     rom$DATA[33:32] == 2'h1 ||
	     WILL_FIRE_RL_fetcher_fsm_action_l78c22 ;
  assign fsl_out_fifo$DEQ = EN_fsl_out_get ;
  assign fsl_out_fifo$CLR = 1'b0 ;

  // submodule rom
  assign rom$ADDR = address ;
  assign rom$EN =
	     WILL_FIRE_RL_fetcher_fsm_action_l58c25 ||
	     WILL_FIRE_RL_fetcher_fsm_action_l54c9 ;

  // remaining internal signals
  assign fetcher_fsm_abort_whas_AND_fetcher_fsm_abort_w_ETC___d70 =
	     fetcher_fsm_state_mkFSMstate == 3'd0 &&
	     (!fetcher_fsm_start_reg_1 || fetcher_fsm_state_fired) ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (!RST_N)
      begin
        address <= `BSV_ASSIGNMENT_DELAY 8'd0;
	booting <= `BSV_ASSIGNMENT_DELAY 1'd1;
	fetcher_fsm_start_reg <= `BSV_ASSIGNMENT_DELAY 1'd0;
	fetcher_fsm_start_reg_1 <= `BSV_ASSIGNMENT_DELAY 1'd0;
	fetcher_fsm_state_can_overlap <= `BSV_ASSIGNMENT_DELAY 1'd1;
	fetcher_fsm_state_fired <= `BSV_ASSIGNMENT_DELAY 1'd0;
	fetcher_fsm_state_mkFSMstate <= `BSV_ASSIGNMENT_DELAY 3'd0;
      end
    else
      begin
        if (address$EN) address <= `BSV_ASSIGNMENT_DELAY address$D_IN;
	if (booting$EN) booting <= `BSV_ASSIGNMENT_DELAY booting$D_IN;
	if (fetcher_fsm_start_reg$EN)
	  fetcher_fsm_start_reg <= `BSV_ASSIGNMENT_DELAY
	      fetcher_fsm_start_reg$D_IN;
	if (fetcher_fsm_start_reg_1$EN)
	  fetcher_fsm_start_reg_1 <= `BSV_ASSIGNMENT_DELAY
	      fetcher_fsm_start_reg_1$D_IN;
	if (fetcher_fsm_state_can_overlap$EN)
	  fetcher_fsm_state_can_overlap <= `BSV_ASSIGNMENT_DELAY
	      fetcher_fsm_state_can_overlap$D_IN;
	if (fetcher_fsm_state_fired$EN)
	  fetcher_fsm_state_fired <= `BSV_ASSIGNMENT_DELAY
	      fetcher_fsm_state_fired$D_IN;
	if (fetcher_fsm_state_mkFSMstate$EN)
	  fetcher_fsm_state_mkFSMstate <= `BSV_ASSIGNMENT_DELAY
	      fetcher_fsm_state_mkFSMstate$D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    address = 8'hAA;
    booting = 1'h0;
    fetcher_fsm_start_reg = 1'h0;
    fetcher_fsm_start_reg_1 = 1'h0;
    fetcher_fsm_state_can_overlap = 1'h0;
    fetcher_fsm_state_fired = 1'h0;
    fetcher_fsm_state_mkFSMstate = 3'h2;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on

  // handling of system tasks

  // synopsys translate_off
  always@(negedge CLK)
  begin
    #0;
    if (RST_N)
      if (WILL_FIRE_RL_fetcher_fsm_action_l54c9 &&
	  (WILL_FIRE_RL_fetcher_fsm_action_l58c25 ||
	   WILL_FIRE_RL_fetcher_fsm_action_l78c22))
	$display("Error: \"BootPattern.bsv\", line 54, column 9: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_fetcher_fsm_action_l54c9] and\n  [RL_fetcher_fsm_action_l58c25, RL_fetcher_fsm_action_l78c22] ) fired in the\n  same clock cycle.\n");
    if (RST_N)
      if (WILL_FIRE_RL_fetcher_fsm_action_l58c25 &&
	  WILL_FIRE_RL_fetcher_fsm_action_l78c22)
	$display("Error: \"BootPattern.bsv\", line 58, column 25: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_fetcher_fsm_action_l58c25]\n  and [RL_fetcher_fsm_action_l78c22] ) fired in the same clock cycle.\n");
  end
  // synopsys translate_on
endmodule  // mkBootPattern

