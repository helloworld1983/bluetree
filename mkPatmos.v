//
// Generated by Bluespec Compiler, version 2012.01.A (build 26572, 2012-01-17)
//
// On Mon Jan 13 17:31:37 GMT 2014
//
// Method conflict info:
// Method: client_request_get
// Conflict-free: bluetile_request_get, bluetile_response_put, start
// Sequenced before: client_response_put
// Conflicts: client_request_get
//
// Method: client_response_put
// Conflict-free: bluetile_request_get, bluetile_response_put, start
// Sequenced after: client_request_get
// Conflicts: client_response_put
//
// Method: bluetile_request_get
// Conflict-free: client_request_get,
// 	       client_response_put,
// 	       bluetile_response_put,
// 	       start
// Conflicts: bluetile_request_get
//
// Method: bluetile_response_put
// Conflict-free: client_request_get,
// 	       client_response_put,
// 	       bluetile_request_get,
// 	       start
// Conflicts: bluetile_response_put
//
// Method: start
// Conflict-free: client_request_get,
// 	       client_response_put,
// 	       bluetile_request_get,
// 	       bluetile_response_put
// Sequenced before (restricted): start
//
//
// Ports:
// Name                         I/O  size props
// client_request_get             O   198 reg
// RDY_client_request_get         O     1
// RDY_client_response_put        O     1
// bluetile_request_get           O    32 reg
// RDY_bluetile_request_get       O     1 reg
// RDY_bluetile_response_put      O     1 reg
// RDY_start                      O     1 const
// CLK                            I     1 clock
// RST_N                          I     1 reset
// client_response_put            I   175
// bluetile_response_put          I    32 reg
// EN_client_response_put         I     1
// EN_bluetile_response_put       I     1
// EN_start                       I     1
// EN_client_request_get          I     1
// EN_bluetile_request_get        I     1
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
`define BSV_ASSIGNMENT_DELAY
`endif

module mkPatmos(CLK,
		RST_N,

		EN_client_request_get,
		client_request_get,
		RDY_client_request_get,

		client_response_put,
		EN_client_response_put,
		RDY_client_response_put,

		EN_bluetile_request_get,
		bluetile_request_get,
		RDY_bluetile_request_get,

		bluetile_response_put,
		EN_bluetile_response_put,
		RDY_bluetile_response_put,

		EN_start,
		RDY_start);
  input  CLK;
  input  RST_N;

  // actionvalue method client_request_get
  input  EN_client_request_get;
  output [197 : 0] client_request_get;
  output RDY_client_request_get;

  // action method client_response_put
  input  [174 : 0] client_response_put;
  input  EN_client_response_put;
  output RDY_client_response_put;

  // actionvalue method bluetile_request_get
  input  EN_bluetile_request_get;
  output [31 : 0] bluetile_request_get;
  output RDY_bluetile_request_get;

  // action method bluetile_response_put
  input  [31 : 0] bluetile_response_put;
  input  EN_bluetile_response_put;
  output RDY_bluetile_response_put;

  // action method start
  input  EN_start;
  output RDY_start;

  // signals for module outputs
  wire [197 : 0] client_request_get;
  wire [31 : 0] bluetile_request_get;
  wire RDY_bluetile_request_get,
       RDY_bluetile_response_put,
       RDY_client_request_get,
       RDY_client_response_put,
       RDY_start;

  // inlined wires
  wire [2 : 0] pat_bt_sm_state_setWire$wget;
  wire pat_bt_data_out$whas,
       pat_bt_sm_state_resetWire$whas,
       pat_bt_sm_state_setWire$whas;

  // register hold
  reg hold;
  wire hold$D_IN, hold$EN;

  // register pat_bt_data_offset
  reg [3 : 0] pat_bt_data_offset;
  wire [3 : 0] pat_bt_data_offset$D_IN;
  wire pat_bt_data_offset$EN;

  // register pat_bt_data_tmp
  reg [31 : 0] pat_bt_data_tmp;
  wire [31 : 0] pat_bt_data_tmp$D_IN;
  wire pat_bt_data_tmp$EN;

  // register pat_bt_sm_state_dataReg
  reg [2 : 0] pat_bt_sm_state_dataReg;
  reg [2 : 0] pat_bt_sm_state_dataReg$D_IN;
  wire pat_bt_sm_state_dataReg$EN;

  // register pat_tree_data_resp
  reg [174 : 0] pat_tree_data_resp;
  wire [174 : 0] pat_tree_data_resp$D_IN;
  wire pat_tree_data_resp$EN;

  // register pat_tree_pkt_ok
  reg pat_tree_pkt_ok;
  wire pat_tree_pkt_ok$D_IN, pat_tree_pkt_ok$EN;

  // register pat_tree_pkt_rd_ptr
  reg [1 : 0] pat_tree_pkt_rd_ptr;
  wire [1 : 0] pat_tree_pkt_rd_ptr$D_IN;
  wire pat_tree_pkt_rd_ptr$EN;

  // register pat_tree_resp_rd_ptr
  reg [1 : 0] pat_tree_resp_rd_ptr;
  wire [1 : 0] pat_tree_resp_rd_ptr$D_IN;
  wire pat_tree_resp_rd_ptr$EN;

  // register pat_tree_sm_state
  reg [2 : 0] pat_tree_sm_state;
  reg [2 : 0] pat_tree_sm_state$D_IN;
  wire pat_tree_sm_state$EN;

  // register pat_tree_tmp_pkt
  reg [197 : 0] pat_tree_tmp_pkt;
  reg [197 : 0] pat_tree_tmp_pkt$D_IN;
  wire pat_tree_tmp_pkt$EN;

  // ports of submodule core
  wire [31 : 0] core$io_comSpm_M_Addr,
		core$io_comSpm_M_Data,
		core$io_comSpm_S_Data,
		core$io_mem_interface_M_Addr,
		core$io_mem_interface_M_Data,
		core$io_mem_interface_S_Data;
  wire [3 : 0] core$io_mem_interface_M_DataByteEn;
  wire [2 : 0] core$io_comSpm_M_Cmd, core$io_mem_interface_M_Cmd;
  wire [1 : 0] core$io_comSpm_S_Resp, core$io_mem_interface_S_Resp;
  wire core$hold,
       core$io_mem_interface_M_DataValid,
       core$io_mem_interface_S_CmdAccept,
       core$io_mem_interface_S_DataAccept;

  // ports of submodule pat_bt_in_fifo
  wire [31 : 0] pat_bt_in_fifo$D_IN, pat_bt_in_fifo$D_OUT;
  wire pat_bt_in_fifo$CLR,
       pat_bt_in_fifo$DEQ,
       pat_bt_in_fifo$EMPTY_N,
       pat_bt_in_fifo$ENQ,
       pat_bt_in_fifo$FULL_N;

  // ports of submodule pat_bt_out_fifo
  wire [31 : 0] pat_bt_out_fifo$D_IN, pat_bt_out_fifo$D_OUT;
  wire pat_bt_out_fifo$CLR,
       pat_bt_out_fifo$DEQ,
       pat_bt_out_fifo$EMPTY_N,
       pat_bt_out_fifo$ENQ,
       pat_bt_out_fifo$FULL_N;

  // rule scheduling signals
  wire WILL_FIRE_RL_pat_bt_continue_read_actual,
       WILL_FIRE_RL_pat_bt_continue_read_status,
       WILL_FIRE_RL_pat_bt_continue_write,
       WILL_FIRE_RL_pat_bt_continue_write_status,
       WILL_FIRE_RL_pat_tree_continue_write,
       WILL_FIRE_RL_pat_tree_incoming_read,
       WILL_FIRE_RL_pat_tree_incoming_write;

  // inputs to muxes for submodule ports
  wire [197 : 0] MUX_pat_tree_tmp_pkt$write_1__VAL_1,
		 MUX_pat_tree_tmp_pkt$write_1__VAL_2,
		 MUX_pat_tree_tmp_pkt$write_1__VAL_3;
  wire [174 : 0] MUX_pat_tree_data_resp$write_1__VAL_1;
  wire [31 : 0] MUX_core$burst_put_SData_1__VAL_1,
		MUX_pat_bt_data_out$wset_1__VAL_2,
		MUX_pat_bt_data_out$wset_1__VAL_3;
  wire [1 : 0] MUX_pat_tree_pkt_rd_ptr$write_1__VAL_1;
  wire MUX_pat_tree_data_resp$write_1__SEL_1,
       MUX_pat_tree_pkt_ok$write_1__SEL_1,
       MUX_pat_tree_sm_state$write_1__SEL_1;

  // remaining internal signals
  reg [31 : 0] x1__h3365;
  wire [127 : 0] pkt_data__h1182, pkt_data__h862, x_data__h1815;
  wire [15 : 0] pkt_ben__h1183, pkt_ben__h863;

  // actionvalue method client_request_get
  assign client_request_get = pat_tree_tmp_pkt ;
  assign RDY_client_request_get =
	     pat_tree_pkt_ok && pat_tree_sm_state == 3'd3 ;

  // action method client_response_put
  assign RDY_client_response_put = pat_tree_sm_state == 3'd3 ;

  // actionvalue method bluetile_request_get
  assign bluetile_request_get = pat_bt_out_fifo$D_OUT ;
  assign RDY_bluetile_request_get = pat_bt_out_fifo$EMPTY_N ;

  // action method bluetile_response_put
  assign RDY_bluetile_response_put = pat_bt_in_fifo$FULL_N ;

  // action method start
  assign RDY_start = 1'd1 ;

  // submodule core
  patmos_top core(.clk(CLK),
		  .rst_n(RST_N),
		  .io_comSpm_S_Data(core$io_comSpm_S_Data),
		  .io_comSpm_S_Resp(core$io_comSpm_S_Resp),
		  .io_mem_interface_S_Data(core$io_mem_interface_S_Data),
		  .io_mem_interface_S_Resp(core$io_mem_interface_S_Resp),
		  .io_mem_interface_S_CmdAccept(core$io_mem_interface_S_CmdAccept),
		  .io_mem_interface_S_DataAccept(core$io_mem_interface_S_DataAccept),
		  .hold(core$hold),
		  .io_mem_interface_M_Cmd(core$io_mem_interface_M_Cmd),
		  .io_mem_interface_M_Addr(core$io_mem_interface_M_Addr),
		  .io_mem_interface_M_Data(core$io_mem_interface_M_Data),
		  .io_mem_interface_M_DataValid(core$io_mem_interface_M_DataValid),
		  .io_mem_interface_M_DataByteEn(core$io_mem_interface_M_DataByteEn),
		  .io_comSpm_M_Cmd(core$io_comSpm_M_Cmd),
		  .io_comSpm_M_Addr(core$io_comSpm_M_Addr),
		  .io_comSpm_M_Data(core$io_comSpm_M_Data),
		  .io_comSpm_M_ByteEn());

  // submodule pat_bt_in_fifo
  FIFO2 #(.width(32'd32), .guarded(32'd1)) pat_bt_in_fifo(.RST_N(RST_N),
							  .CLK(CLK),
							  .D_IN(pat_bt_in_fifo$D_IN),
							  .ENQ(pat_bt_in_fifo$ENQ),
							  .DEQ(pat_bt_in_fifo$DEQ),
							  .CLR(pat_bt_in_fifo$CLR),
							  .D_OUT(pat_bt_in_fifo$D_OUT),
							  .FULL_N(pat_bt_in_fifo$FULL_N),
							  .EMPTY_N(pat_bt_in_fifo$EMPTY_N));

  // submodule pat_bt_out_fifo
  FIFO2 #(.width(32'd32), .guarded(32'd1)) pat_bt_out_fifo(.RST_N(RST_N),
							   .CLK(CLK),
							   .D_IN(pat_bt_out_fifo$D_IN),
							   .ENQ(pat_bt_out_fifo$ENQ),
							   .DEQ(pat_bt_out_fifo$DEQ),
							   .CLR(pat_bt_out_fifo$CLR),
							   .D_OUT(pat_bt_out_fifo$D_OUT),
							   .FULL_N(pat_bt_out_fifo$FULL_N),
							   .EMPTY_N(pat_bt_out_fifo$EMPTY_N));

  // rule RL_pat_bt_continue_read_status
  assign WILL_FIRE_RL_pat_bt_continue_read_status =
	     pat_bt_sm_state_dataReg == 3'd1 && pat_bt_data_offset == 4'd4 ;

  // rule RL_pat_bt_continue_write_status
  assign WILL_FIRE_RL_pat_bt_continue_write_status =
	     pat_bt_sm_state_dataReg == 3'd1 && pat_bt_data_offset == 4'd8 ;

  // rule RL_pat_tree_incoming_read
  assign WILL_FIRE_RL_pat_tree_incoming_read =
	     pat_tree_sm_state == 3'd0 &&
	     core$io_mem_interface_M_Cmd == 3'd2 ;

  // rule RL_pat_tree_incoming_write
  assign WILL_FIRE_RL_pat_tree_incoming_write =
	     pat_tree_sm_state == 3'd0 &&
	     core$io_mem_interface_M_Cmd == 3'd1 &&
	     core$io_mem_interface_M_DataValid ;

  // rule RL_pat_tree_continue_write
  assign WILL_FIRE_RL_pat_tree_continue_write =
	     pat_tree_sm_state == 3'd2 && core$io_mem_interface_M_DataValid &&
	     !pat_tree_pkt_ok ;

  // rule RL_pat_bt_continue_read_actual
  assign WILL_FIRE_RL_pat_bt_continue_read_actual =
	     pat_bt_in_fifo$EMPTY_N && pat_bt_sm_state_dataReg == 3'd1 &&
	     pat_bt_data_offset == 4'd0 ;

  // rule RL_pat_bt_continue_write
  assign WILL_FIRE_RL_pat_bt_continue_write =
	     pat_bt_out_fifo$FULL_N && pat_bt_sm_state_dataReg == 3'd2 &&
	     pat_bt_data_offset == 4'd0 ;

  // inputs to muxes for submodule ports
  assign MUX_pat_tree_data_resp$write_1__SEL_1 =
	     pat_tree_sm_state == 3'd4 &&
	     pat_tree_data_resp[174:172] != 3'd3 ;
  assign MUX_pat_tree_pkt_ok$write_1__SEL_1 =
	     WILL_FIRE_RL_pat_tree_continue_write &&
	     pat_tree_pkt_rd_ptr == 2'd3 ;
  assign MUX_pat_tree_sm_state$write_1__SEL_1 =
	     pat_tree_sm_state == 3'd4 &&
	     (pat_tree_data_resp[174:172] == 3'd3 ||
	      pat_tree_resp_rd_ptr == 2'd3) ;
  assign MUX_core$burst_put_SData_1__VAL_1 =
	     (pat_tree_data_resp[174:172] == 3'd3) ?
	       32'd0 :
	       pat_tree_data_resp[75:44] ;
  assign MUX_pat_bt_data_out$wset_1__VAL_2 =
	     pat_bt_in_fifo$EMPTY_N ? 32'd1 : 32'd0 ;
  assign MUX_pat_bt_data_out$wset_1__VAL_3 =
	     pat_bt_out_fifo$FULL_N ? 32'd1 : 32'd0 ;
  assign MUX_pat_tree_data_resp$write_1__VAL_1 =
	     { pat_tree_data_resp[174:172],
	       x_data__h1815,
	       pat_tree_data_resp[43:0] } ;
  assign MUX_pat_tree_pkt_rd_ptr$write_1__VAL_1 =
	     (pat_tree_pkt_rd_ptr == 2'd3) ?
	       2'd0 :
	       pat_tree_pkt_rd_ptr + 2'd1 ;
  assign MUX_pat_tree_tmp_pkt$write_1__VAL_1 =
	     { 146'd0, core$io_mem_interface_M_Addr[31:4], 24'd0 } ;
  assign MUX_pat_tree_tmp_pkt$write_1__VAL_2 =
	     { 2'd0,
	       pkt_data__h862,
	       pkt_ben__h863,
	       core$io_mem_interface_M_Addr[31:4],
	       24'd0 } ;
  assign MUX_pat_tree_tmp_pkt$write_1__VAL_3 =
	     { pat_tree_tmp_pkt[197:196],
	       pkt_data__h1182,
	       pkt_ben__h1183,
	       pat_tree_tmp_pkt[51:0] } ;

  // inlined wires
  assign pat_bt_sm_state_setWire$wget =
	     (core$io_comSpm_M_Cmd == 3'd2) ? 3'd1 : 3'd2 ;
  assign pat_bt_sm_state_setWire$whas =
	     core$io_comSpm_M_Cmd == 3'd2 || core$io_comSpm_M_Cmd == 3'd1 ;
  assign pat_bt_data_out$whas =
	     WILL_FIRE_RL_pat_bt_continue_read_actual ||
	     WILL_FIRE_RL_pat_bt_continue_read_status ||
	     WILL_FIRE_RL_pat_bt_continue_write_status ;
  assign pat_bt_sm_state_resetWire$whas =
	     WILL_FIRE_RL_pat_bt_continue_write_status ||
	     WILL_FIRE_RL_pat_bt_continue_read_status ||
	     WILL_FIRE_RL_pat_bt_continue_write ||
	     WILL_FIRE_RL_pat_bt_continue_read_actual ;

  // register hold
  assign hold$D_IN = 1'd0 ;
  assign hold$EN = EN_start ;

  // register pat_bt_data_offset
  assign pat_bt_data_offset$D_IN = core$io_comSpm_M_Addr[3:0] ;
  assign pat_bt_data_offset$EN =
	     core$io_comSpm_M_Cmd == 3'd1 || core$io_comSpm_M_Cmd == 3'd2 ;

  // register pat_bt_data_tmp
  assign pat_bt_data_tmp$D_IN = core$io_comSpm_M_Data ;
  assign pat_bt_data_tmp$EN = core$io_comSpm_M_Cmd == 3'd1 ;

  // register pat_bt_sm_state_dataReg
  always@(core$io_comSpm_M_Cmd or pat_bt_sm_state_setWire$wget)
  begin
    case (core$io_comSpm_M_Cmd)
      3'd1, 3'd2: pat_bt_sm_state_dataReg$D_IN = pat_bt_sm_state_setWire$wget;
      default: pat_bt_sm_state_dataReg$D_IN = 3'd0;
    endcase
  end
  assign pat_bt_sm_state_dataReg$EN =
	     pat_bt_sm_state_setWire$whas || pat_bt_sm_state_resetWire$whas ;

  // register pat_tree_data_resp
  assign pat_tree_data_resp$D_IN =
	     MUX_pat_tree_data_resp$write_1__SEL_1 ?
	       MUX_pat_tree_data_resp$write_1__VAL_1 :
	       client_response_put ;
  assign pat_tree_data_resp$EN =
	     pat_tree_sm_state == 3'd4 &&
	     pat_tree_data_resp[174:172] != 3'd3 ||
	     EN_client_response_put ;

  // register pat_tree_pkt_ok
  assign pat_tree_pkt_ok$D_IN = !EN_client_request_get ;
  assign pat_tree_pkt_ok$EN =
	     WILL_FIRE_RL_pat_tree_continue_write &&
	     pat_tree_pkt_rd_ptr == 2'd3 ||
	     EN_client_request_get ||
	     WILL_FIRE_RL_pat_tree_incoming_read ;

  // register pat_tree_pkt_rd_ptr
  assign pat_tree_pkt_rd_ptr$D_IN =
	     WILL_FIRE_RL_pat_tree_continue_write ?
	       MUX_pat_tree_pkt_rd_ptr$write_1__VAL_1 :
	       2'd1 ;
  assign pat_tree_pkt_rd_ptr$EN =
	     WILL_FIRE_RL_pat_tree_continue_write ||
	     WILL_FIRE_RL_pat_tree_incoming_write ;

  // register pat_tree_resp_rd_ptr
  assign pat_tree_resp_rd_ptr$D_IN =
	     (pat_tree_resp_rd_ptr == 2'd3) ?
	       2'd0 :
	       pat_tree_resp_rd_ptr + 2'd1 ;
  assign pat_tree_resp_rd_ptr$EN = MUX_pat_tree_data_resp$write_1__SEL_1 ;

  // register pat_tree_sm_state
  always@(MUX_pat_tree_sm_state$write_1__SEL_1 or
	  WILL_FIRE_RL_pat_tree_incoming_write or
	  MUX_pat_tree_pkt_ok$write_1__SEL_1 or
	  WILL_FIRE_RL_pat_tree_incoming_read or EN_client_response_put)
  begin
    case (1'b1) // synopsys parallel_case
      MUX_pat_tree_sm_state$write_1__SEL_1: pat_tree_sm_state$D_IN = 3'd0;
      WILL_FIRE_RL_pat_tree_incoming_write: pat_tree_sm_state$D_IN = 3'd2;
      MUX_pat_tree_pkt_ok$write_1__SEL_1 ||
      WILL_FIRE_RL_pat_tree_incoming_read:
	  pat_tree_sm_state$D_IN = 3'd3;
      EN_client_response_put: pat_tree_sm_state$D_IN = 3'd4;
      default: pat_tree_sm_state$D_IN = 3'bxxx /* unspecified value */ ;
    endcase
  end
  assign pat_tree_sm_state$EN =
	     pat_tree_sm_state == 3'd4 &&
	     (pat_tree_data_resp[174:172] == 3'd3 ||
	      pat_tree_resp_rd_ptr == 2'd3) ||
	     WILL_FIRE_RL_pat_tree_continue_write &&
	     pat_tree_pkt_rd_ptr == 2'd3 ||
	     WILL_FIRE_RL_pat_tree_incoming_write ||
	     WILL_FIRE_RL_pat_tree_incoming_read ||
	     EN_client_response_put ;

  // register pat_tree_tmp_pkt
  always@(WILL_FIRE_RL_pat_tree_incoming_read or
	  MUX_pat_tree_tmp_pkt$write_1__VAL_1 or
	  WILL_FIRE_RL_pat_tree_incoming_write or
	  MUX_pat_tree_tmp_pkt$write_1__VAL_2 or
	  WILL_FIRE_RL_pat_tree_continue_write or
	  MUX_pat_tree_tmp_pkt$write_1__VAL_3)
  begin
    case (1'b1) // synopsys parallel_case
      WILL_FIRE_RL_pat_tree_incoming_read:
	  pat_tree_tmp_pkt$D_IN = MUX_pat_tree_tmp_pkt$write_1__VAL_1;
      WILL_FIRE_RL_pat_tree_incoming_write:
	  pat_tree_tmp_pkt$D_IN = MUX_pat_tree_tmp_pkt$write_1__VAL_2;
      WILL_FIRE_RL_pat_tree_continue_write:
	  pat_tree_tmp_pkt$D_IN = MUX_pat_tree_tmp_pkt$write_1__VAL_3;
      default: pat_tree_tmp_pkt$D_IN =
		   198'bxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx /* unspecified value */ ;
    endcase
  end
  assign pat_tree_tmp_pkt$EN =
	     WILL_FIRE_RL_pat_tree_incoming_read ||
	     WILL_FIRE_RL_pat_tree_incoming_write ||
	     WILL_FIRE_RL_pat_tree_continue_write ;

  // submodule core
  assign core$io_comSpm_S_Data = pat_bt_data_out$whas ? x1__h3365 : 32'd0 ;
  assign core$io_comSpm_S_Resp =
	     pat_bt_sm_state_resetWire$whas ? 2'd1 : 2'd0 ;
  assign core$io_mem_interface_S_Data =
	     (pat_tree_sm_state == 3'd4) ?
	       MUX_core$burst_put_SData_1__VAL_1 :
	       32'd0 ;
  assign core$io_mem_interface_S_Resp =
	     (pat_tree_sm_state != 3'd4) ? 2'd0 : 2'd1 ;
  assign core$io_mem_interface_S_CmdAccept =
	     WILL_FIRE_RL_pat_tree_incoming_write ||
	     WILL_FIRE_RL_pat_tree_incoming_read ;
  assign core$io_mem_interface_S_DataAccept =
	     WILL_FIRE_RL_pat_tree_continue_write ||
	     WILL_FIRE_RL_pat_tree_incoming_write ;
  assign core$hold = hold ;

  // submodule pat_bt_in_fifo
  assign pat_bt_in_fifo$D_IN = bluetile_response_put ;
  assign pat_bt_in_fifo$ENQ = EN_bluetile_response_put ;
  assign pat_bt_in_fifo$DEQ = WILL_FIRE_RL_pat_bt_continue_read_actual ;
  assign pat_bt_in_fifo$CLR = 1'b0 ;

  // submodule pat_bt_out_fifo
  assign pat_bt_out_fifo$D_IN = pat_bt_data_tmp ;
  assign pat_bt_out_fifo$ENQ = WILL_FIRE_RL_pat_bt_continue_write ;
  assign pat_bt_out_fifo$DEQ = EN_bluetile_request_get ;
  assign pat_bt_out_fifo$CLR = 1'b0 ;

  // remaining internal signals
  assign pkt_ben__h1183 =
	     { core$io_mem_interface_M_DataByteEn, pat_tree_tmp_pkt[67:56] } ;
  assign pkt_ben__h863 = { core$io_mem_interface_M_DataByteEn, 12'd0 } ;
  assign pkt_data__h1182 =
	     { core$io_mem_interface_M_Data, pat_tree_tmp_pkt[195:100] } ;
  assign pkt_data__h862 = { core$io_mem_interface_M_Data, 96'd0 } ;
  assign x_data__h1815 = { 32'd0, pat_tree_data_resp[171:76] } ;
  always@(WILL_FIRE_RL_pat_bt_continue_read_actual or
	  pat_bt_in_fifo$D_OUT or
	  WILL_FIRE_RL_pat_bt_continue_read_status or
	  MUX_pat_bt_data_out$wset_1__VAL_2 or
	  WILL_FIRE_RL_pat_bt_continue_write_status or
	  MUX_pat_bt_data_out$wset_1__VAL_3)
  begin
    case (1'b1) // synopsys parallel_case
      WILL_FIRE_RL_pat_bt_continue_read_actual:
	  x1__h3365 = pat_bt_in_fifo$D_OUT;
      WILL_FIRE_RL_pat_bt_continue_read_status:
	  x1__h3365 = MUX_pat_bt_data_out$wset_1__VAL_2;
      WILL_FIRE_RL_pat_bt_continue_write_status:
	  x1__h3365 = MUX_pat_bt_data_out$wset_1__VAL_3;
      default: x1__h3365 =
		   32'bxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx /* unspecified value */ ;
    endcase
  end

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (!RST_N)
      begin
        hold <= `BSV_ASSIGNMENT_DELAY 1'd1;
	pat_bt_data_offset <= `BSV_ASSIGNMENT_DELAY 4'd0;
	pat_bt_data_tmp <= `BSV_ASSIGNMENT_DELAY 32'd0;
	pat_bt_sm_state_dataReg <= `BSV_ASSIGNMENT_DELAY 3'd0;
	pat_tree_data_resp <= `BSV_ASSIGNMENT_DELAY 175'd0;
	pat_tree_pkt_ok <= `BSV_ASSIGNMENT_DELAY 1'd0;
	pat_tree_pkt_rd_ptr <= `BSV_ASSIGNMENT_DELAY 2'd0;
	pat_tree_resp_rd_ptr <= `BSV_ASSIGNMENT_DELAY 2'd0;
	pat_tree_sm_state <= `BSV_ASSIGNMENT_DELAY 3'd0;
	pat_tree_tmp_pkt <= `BSV_ASSIGNMENT_DELAY 198'd0;
      end
    else
      begin
        if (hold$EN) hold <= `BSV_ASSIGNMENT_DELAY hold$D_IN;
	if (pat_bt_data_offset$EN)
	  pat_bt_data_offset <= `BSV_ASSIGNMENT_DELAY pat_bt_data_offset$D_IN;
	if (pat_bt_data_tmp$EN)
	  pat_bt_data_tmp <= `BSV_ASSIGNMENT_DELAY pat_bt_data_tmp$D_IN;
	if (pat_bt_sm_state_dataReg$EN)
	  pat_bt_sm_state_dataReg <= `BSV_ASSIGNMENT_DELAY
	      pat_bt_sm_state_dataReg$D_IN;
	if (pat_tree_data_resp$EN)
	  pat_tree_data_resp <= `BSV_ASSIGNMENT_DELAY pat_tree_data_resp$D_IN;
	if (pat_tree_pkt_ok$EN)
	  pat_tree_pkt_ok <= `BSV_ASSIGNMENT_DELAY pat_tree_pkt_ok$D_IN;
	if (pat_tree_pkt_rd_ptr$EN)
	  pat_tree_pkt_rd_ptr <= `BSV_ASSIGNMENT_DELAY
	      pat_tree_pkt_rd_ptr$D_IN;
	if (pat_tree_resp_rd_ptr$EN)
	  pat_tree_resp_rd_ptr <= `BSV_ASSIGNMENT_DELAY
	      pat_tree_resp_rd_ptr$D_IN;
	if (pat_tree_sm_state$EN)
	  pat_tree_sm_state <= `BSV_ASSIGNMENT_DELAY pat_tree_sm_state$D_IN;
	if (pat_tree_tmp_pkt$EN)
	  pat_tree_tmp_pkt <= `BSV_ASSIGNMENT_DELAY pat_tree_tmp_pkt$D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    hold = 1'h0;
    pat_bt_data_offset = 4'hA;
    pat_bt_data_tmp = 32'hAAAAAAAA;
    pat_bt_sm_state_dataReg = 3'h2;
    pat_tree_data_resp = 175'h2AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA;
    pat_tree_pkt_ok = 1'h0;
    pat_tree_pkt_rd_ptr = 2'h2;
    pat_tree_resp_rd_ptr = 2'h2;
    pat_tree_sm_state = 3'h2;
    pat_tree_tmp_pkt =
	198'h2AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on

  // handling of system tasks

  // synopsys translate_off
  always@(negedge CLK)
  begin
    #0;
    if (RST_N)
      if (WILL_FIRE_RL_pat_bt_continue_read_status)
	$display("PATMOS FSL: Reading read status");
    if (RST_N)
      if (WILL_FIRE_RL_pat_bt_continue_write_status)
	$display("PATMOS FSL: Reading write status");
    if (RST_N)
      if (WILL_FIRE_RL_pat_tree_incoming_read)
	$display("Handing read to addr 0x%x", core$io_mem_interface_M_Addr);
    if (RST_N)
      if (WILL_FIRE_RL_pat_tree_incoming_write)
	$display("Start write to address 0x%x D 0x%x BEN 0x%x",
		 core$io_mem_interface_M_Addr[31:4],
		 pkt_data__h862,
		 pkt_ben__h863);
    if (RST_N)
      if (WILL_FIRE_RL_pat_tree_continue_write)
	$display("Continue write, D 0x%x, BEN 0x%x",
		 pkt_data__h1182,
		 pkt_ben__h1183);
    if (RST_N)
      if (WILL_FIRE_RL_pat_tree_continue_write && pat_tree_pkt_rd_ptr == 2'd3)
	$display("Write complete, dispatching");
    if (RST_N)
      if (WILL_FIRE_RL_pat_bt_continue_read_actual)
	$display("PATMOS FSL: READING");
    if (RST_N)
      if (WILL_FIRE_RL_pat_bt_continue_write) $display("PATMOS FSL: WRITING");
    if (RST_N)
      if (core$io_comSpm_M_Cmd == 3'd2) $display("PATMOS FSL: READ START");
  end
  // synopsys translate_on
endmodule  // mkPatmos

