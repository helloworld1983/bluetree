//
// Generated by Bluespec Compiler, version 2012.01.A (build 26572, 2012-01-17)
//
// On Wed Oct  8 17:02:07 BST 2014
//
// Method conflict info:
// Method: client_request_get
// Conflict-free: start
// Sequenced before: client_response_put
// Conflicts: client_request_get
//
// Method: client_response_put
// Conflict-free: start
// Sequenced after: client_request_get
// Conflicts: client_response_put
//
// Method: start
// Conflict-free: client_request_get, client_response_put
// Sequenced before (restricted): start
//
//
// Ports:
// Name                         I/O  size props
// client_request_get             O   198 reg
// RDY_client_request_get         O     1
// RDY_client_response_put        O     1
// RDY_start                      O     1 const
// CLK                            I     1 clock
// RST_N                          I     1 reset
// client_response_put            I   175
// EN_client_response_put         I     1
// EN_start                       I     1
// EN_client_request_get          I     1
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
`define BSV_ASSIGNMENT_DELAY
`endif

module mkPatmos(CLK,
		RST_N,

		EN_client_request_get,
		client_request_get,
		RDY_client_request_get,

		client_response_put,
		EN_client_response_put,
		RDY_client_response_put,

		EN_start,
		RDY_start);
  input  CLK;
  input  RST_N;

  // actionvalue method client_request_get
  input  EN_client_request_get;
  output [197 : 0] client_request_get;
  output RDY_client_request_get;

  // action method client_response_put
  input  [174 : 0] client_response_put;
  input  EN_client_response_put;
  output RDY_client_response_put;

  // action method start
  input  EN_start;
  output RDY_start;

  // signals for module outputs
  wire [197 : 0] client_request_get;
  wire RDY_client_request_get, RDY_client_response_put, RDY_start;

  // register hold
  reg hold;
  wire hold$D_IN, hold$EN;

  // register pat_tree_data_resp
  reg [174 : 0] pat_tree_data_resp;
  wire [174 : 0] pat_tree_data_resp$D_IN;
  wire pat_tree_data_resp$EN;

  // register pat_tree_pkt_ok
  reg pat_tree_pkt_ok;
  wire pat_tree_pkt_ok$D_IN, pat_tree_pkt_ok$EN;

  // register pat_tree_pkt_rd_ptr
  reg [1 : 0] pat_tree_pkt_rd_ptr;
  wire [1 : 0] pat_tree_pkt_rd_ptr$D_IN;
  wire pat_tree_pkt_rd_ptr$EN;

  // register pat_tree_resp_rd_ptr
  reg [1 : 0] pat_tree_resp_rd_ptr;
  wire [1 : 0] pat_tree_resp_rd_ptr$D_IN;
  wire pat_tree_resp_rd_ptr$EN;

  // register pat_tree_sm_state
  reg [2 : 0] pat_tree_sm_state;
  reg [2 : 0] pat_tree_sm_state$D_IN;
  wire pat_tree_sm_state$EN;

  // register pat_tree_tmp_pkt
  reg [197 : 0] pat_tree_tmp_pkt;
  reg [197 : 0] pat_tree_tmp_pkt$D_IN;
  wire pat_tree_tmp_pkt$EN;

  // ports of submodule core
  wire [31 : 0] core$io_comSpm_S_Data,
		core$io_mem_interface_M_Addr,
		core$io_mem_interface_M_Data,
		core$io_mem_interface_S_Data;
  wire [3 : 0] core$io_mem_interface_M_DataByteEn;
  wire [2 : 0] core$io_mem_interface_M_Cmd;
  wire [1 : 0] core$io_comSpm_S_Resp, core$io_mem_interface_S_Resp;
  wire core$hold,
       core$io_mem_interface_M_DataValid,
       core$io_mem_interface_S_CmdAccept,
       core$io_mem_interface_S_DataAccept;

  // rule scheduling signals
  wire WILL_FIRE_RL_pat_tree_continue_write,
       WILL_FIRE_RL_pat_tree_incoming_read,
       WILL_FIRE_RL_pat_tree_incoming_write,
       WILL_FIRE_RL_pat_tree_tie_off_resp,
       WILL_FIRE_RL_pat_tree_write_reply_F_F,
       WILL_FIRE_RL_pat_tree_write_reply_F_T,
       WILL_FIRE_RL_pat_tree_write_reply_T;

  // inputs to muxes for submodule ports
  wire [197 : 0] MUX_pat_tree_tmp_pkt$write_1__VAL_1,
		 MUX_pat_tree_tmp_pkt$write_1__VAL_2,
		 MUX_pat_tree_tmp_pkt$write_1__VAL_3;
  wire [174 : 0] MUX_pat_tree_data_resp$write_1__VAL_2;
  wire [1 : 0] MUX_pat_tree_pkt_rd_ptr$write_1__VAL_1,
	       MUX_pat_tree_resp_rd_ptr$write_1__VAL_1;
  wire MUX_core$burst_put_SData_1__SEL_1,
       MUX_pat_tree_pkt_ok$write_1__SEL_1,
       MUX_pat_tree_sm_state$write_1__SEL_2;

  // remaining internal signals
  wire [127 : 0] pkt_data__h1182, pkt_data__h862, x_data__h1821;
  wire [15 : 0] pkt_ben__h1183, pkt_ben__h863;

  // actionvalue method client_request_get
  assign client_request_get = pat_tree_tmp_pkt ;
  assign RDY_client_request_get =
	     pat_tree_pkt_ok && pat_tree_sm_state == 3'd3 ;

  // action method client_response_put
  assign RDY_client_response_put = pat_tree_sm_state == 3'd3 ;

  // action method start
  assign RDY_start = 1'd1 ;

  // submodule core
  patmos_top core(.clk(CLK),
		  .rst_n(RST_N),
		  .io_comSpm_S_Data(core$io_comSpm_S_Data),
		  .io_comSpm_S_Resp(core$io_comSpm_S_Resp),
		  .io_mem_interface_S_Data(core$io_mem_interface_S_Data),
		  .io_mem_interface_S_Resp(core$io_mem_interface_S_Resp),
		  .io_mem_interface_S_CmdAccept(core$io_mem_interface_S_CmdAccept),
		  .io_mem_interface_S_DataAccept(core$io_mem_interface_S_DataAccept),
		  .hold(core$hold),
		  .io_mem_interface_M_Cmd(core$io_mem_interface_M_Cmd),
		  .io_mem_interface_M_Addr(core$io_mem_interface_M_Addr),
		  .io_mem_interface_M_Data(core$io_mem_interface_M_Data),
		  .io_mem_interface_M_DataValid(core$io_mem_interface_M_DataValid),
		  .io_mem_interface_M_DataByteEn(core$io_mem_interface_M_DataByteEn),
		  .io_comSpm_M_Cmd(),
		  .io_comSpm_M_Addr(),
		  .io_comSpm_M_Data(),
		  .io_comSpm_M_ByteEn());

  // rule RL_pat_tree_incoming_read
  assign WILL_FIRE_RL_pat_tree_incoming_read =
	     pat_tree_sm_state == 3'd0 &&
	     core$io_mem_interface_M_Cmd == 3'd2 ;

  // rule RL_pat_tree_incoming_write
  assign WILL_FIRE_RL_pat_tree_incoming_write =
	     pat_tree_sm_state == 3'd0 &&
	     core$io_mem_interface_M_Cmd == 3'd1 &&
	     core$io_mem_interface_M_DataValid ;

  // rule RL_pat_tree_continue_write
  assign WILL_FIRE_RL_pat_tree_continue_write =
	     pat_tree_sm_state == 3'd2 && core$io_mem_interface_M_DataValid &&
	     !pat_tree_pkt_ok ;

  // rule RL_pat_tree_write_reply_T
  assign WILL_FIRE_RL_pat_tree_write_reply_T =
	     pat_tree_data_resp[174:172] == 3'd3 &&
	     pat_tree_sm_state == 3'd4 ;

  // rule RL_pat_tree_write_reply_F_T
  assign WILL_FIRE_RL_pat_tree_write_reply_F_T =
	     pat_tree_data_resp[174:172] != 3'd3 &&
	     pat_tree_resp_rd_ptr == 2'd3 &&
	     pat_tree_sm_state == 3'd4 ;

  // rule RL_pat_tree_write_reply_F_F
  assign WILL_FIRE_RL_pat_tree_write_reply_F_F =
	     pat_tree_data_resp[174:172] != 3'd3 &&
	     pat_tree_resp_rd_ptr != 2'd3 &&
	     pat_tree_sm_state == 3'd4 ;

  // rule RL_pat_tree_tie_off_resp
  assign WILL_FIRE_RL_pat_tree_tie_off_resp =
	     !WILL_FIRE_RL_pat_tree_write_reply_F_F &&
	     !WILL_FIRE_RL_pat_tree_write_reply_F_T &&
	     !WILL_FIRE_RL_pat_tree_write_reply_T ;

  // inputs to muxes for submodule ports
  assign MUX_core$burst_put_SData_1__SEL_1 =
	     WILL_FIRE_RL_pat_tree_write_reply_F_F ||
	     WILL_FIRE_RL_pat_tree_write_reply_F_T ;
  assign MUX_pat_tree_pkt_ok$write_1__SEL_1 =
	     WILL_FIRE_RL_pat_tree_continue_write &&
	     pat_tree_pkt_rd_ptr == 2'd3 ;
  assign MUX_pat_tree_sm_state$write_1__SEL_2 =
	     WILL_FIRE_RL_pat_tree_write_reply_F_T ||
	     WILL_FIRE_RL_pat_tree_write_reply_T ;
  assign MUX_pat_tree_data_resp$write_1__VAL_2 =
	     { pat_tree_data_resp[174:172],
	       x_data__h1821,
	       pat_tree_data_resp[43:0] } ;
  assign MUX_pat_tree_pkt_rd_ptr$write_1__VAL_1 =
	     (pat_tree_pkt_rd_ptr == 2'd3) ?
	       2'd0 :
	       pat_tree_pkt_rd_ptr + 2'd1 ;
  assign MUX_pat_tree_resp_rd_ptr$write_1__VAL_1 =
	     pat_tree_resp_rd_ptr + 2'd1 ;
  assign MUX_pat_tree_tmp_pkt$write_1__VAL_1 =
	     { 146'd0, core$io_mem_interface_M_Addr[31:4], 24'd0 } ;
  assign MUX_pat_tree_tmp_pkt$write_1__VAL_2 =
	     { 2'd0,
	       pkt_data__h862,
	       pkt_ben__h863,
	       core$io_mem_interface_M_Addr[31:4],
	       24'd0 } ;
  assign MUX_pat_tree_tmp_pkt$write_1__VAL_3 =
	     { pat_tree_tmp_pkt[197:196],
	       pkt_data__h1182,
	       pkt_ben__h1183,
	       pat_tree_tmp_pkt[51:0] } ;

  // register hold
  assign hold$D_IN = 1'd0 ;
  assign hold$EN = EN_start ;

  // register pat_tree_data_resp
  assign pat_tree_data_resp$D_IN =
	     EN_client_response_put ?
	       client_response_put :
	       MUX_pat_tree_data_resp$write_1__VAL_2 ;
  assign pat_tree_data_resp$EN =
	     EN_client_response_put ||
	     WILL_FIRE_RL_pat_tree_write_reply_F_F ||
	     WILL_FIRE_RL_pat_tree_write_reply_F_T ;

  // register pat_tree_pkt_ok
  assign pat_tree_pkt_ok$D_IN = !EN_client_request_get ;
  assign pat_tree_pkt_ok$EN =
	     WILL_FIRE_RL_pat_tree_continue_write &&
	     pat_tree_pkt_rd_ptr == 2'd3 ||
	     EN_client_request_get ||
	     WILL_FIRE_RL_pat_tree_incoming_read ;

  // register pat_tree_pkt_rd_ptr
  assign pat_tree_pkt_rd_ptr$D_IN =
	     WILL_FIRE_RL_pat_tree_continue_write ?
	       MUX_pat_tree_pkt_rd_ptr$write_1__VAL_1 :
	       2'd1 ;
  assign pat_tree_pkt_rd_ptr$EN =
	     WILL_FIRE_RL_pat_tree_continue_write ||
	     WILL_FIRE_RL_pat_tree_incoming_write ;

  // register pat_tree_resp_rd_ptr
  assign pat_tree_resp_rd_ptr$D_IN =
	     WILL_FIRE_RL_pat_tree_write_reply_F_F ?
	       MUX_pat_tree_resp_rd_ptr$write_1__VAL_1 :
	       2'd0 ;
  assign pat_tree_resp_rd_ptr$EN = MUX_core$burst_put_SData_1__SEL_1 ;

  // register pat_tree_sm_state
  always@(MUX_pat_tree_sm_state$write_1__SEL_2 or
	  WILL_FIRE_RL_pat_tree_incoming_write or
	  MUX_pat_tree_pkt_ok$write_1__SEL_1 or
	  WILL_FIRE_RL_pat_tree_incoming_read or EN_client_response_put)
  begin
    case (1'b1) // synopsys parallel_case
      MUX_pat_tree_sm_state$write_1__SEL_2: pat_tree_sm_state$D_IN = 3'd0;
      WILL_FIRE_RL_pat_tree_incoming_write: pat_tree_sm_state$D_IN = 3'd2;
      MUX_pat_tree_pkt_ok$write_1__SEL_1 ||
      WILL_FIRE_RL_pat_tree_incoming_read:
	  pat_tree_sm_state$D_IN = 3'd3;
      EN_client_response_put: pat_tree_sm_state$D_IN = 3'd4;
      default: pat_tree_sm_state$D_IN = 3'b010 /* unspecified value */ ;
    endcase
  end
  assign pat_tree_sm_state$EN =
	     WILL_FIRE_RL_pat_tree_continue_write &&
	     pat_tree_pkt_rd_ptr == 2'd3 ||
	     WILL_FIRE_RL_pat_tree_write_reply_F_T ||
	     WILL_FIRE_RL_pat_tree_write_reply_T ||
	     WILL_FIRE_RL_pat_tree_incoming_write ||
	     WILL_FIRE_RL_pat_tree_incoming_read ||
	     EN_client_response_put ;

  // register pat_tree_tmp_pkt
  always@(WILL_FIRE_RL_pat_tree_incoming_read or
	  MUX_pat_tree_tmp_pkt$write_1__VAL_1 or
	  WILL_FIRE_RL_pat_tree_incoming_write or
	  MUX_pat_tree_tmp_pkt$write_1__VAL_2 or
	  WILL_FIRE_RL_pat_tree_continue_write or
	  MUX_pat_tree_tmp_pkt$write_1__VAL_3)
  begin
    case (1'b1) // synopsys parallel_case
      WILL_FIRE_RL_pat_tree_incoming_read:
	  pat_tree_tmp_pkt$D_IN = MUX_pat_tree_tmp_pkt$write_1__VAL_1;
      WILL_FIRE_RL_pat_tree_incoming_write:
	  pat_tree_tmp_pkt$D_IN = MUX_pat_tree_tmp_pkt$write_1__VAL_2;
      WILL_FIRE_RL_pat_tree_continue_write:
	  pat_tree_tmp_pkt$D_IN = MUX_pat_tree_tmp_pkt$write_1__VAL_3;
      default: pat_tree_tmp_pkt$D_IN =
		   198'h2AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA /* unspecified value */ ;
    endcase
  end
  assign pat_tree_tmp_pkt$EN =
	     WILL_FIRE_RL_pat_tree_incoming_read ||
	     WILL_FIRE_RL_pat_tree_incoming_write ||
	     WILL_FIRE_RL_pat_tree_continue_write ;

  // submodule core
  assign core$io_comSpm_S_Data = 32'h0 ;
  assign core$io_comSpm_S_Resp = 2'h0 ;
  assign core$io_mem_interface_S_Data =
	     MUX_core$burst_put_SData_1__SEL_1 ?
	       pat_tree_data_resp[75:44] :
	       32'd0 ;
  assign core$io_mem_interface_S_Resp =
	     WILL_FIRE_RL_pat_tree_tie_off_resp ? 2'd0 : 2'd1 ;
  assign core$io_mem_interface_S_CmdAccept =
	     WILL_FIRE_RL_pat_tree_incoming_write ||
	     WILL_FIRE_RL_pat_tree_incoming_read ;
  assign core$io_mem_interface_S_DataAccept =
	     WILL_FIRE_RL_pat_tree_continue_write ||
	     WILL_FIRE_RL_pat_tree_incoming_write ;
  assign core$hold = hold ;

  // remaining internal signals
  assign pkt_ben__h1183 =
	     { core$io_mem_interface_M_DataByteEn, pat_tree_tmp_pkt[67:56] } ;
  assign pkt_ben__h863 = { core$io_mem_interface_M_DataByteEn, 12'd0 } ;
  assign pkt_data__h1182 =
	     { core$io_mem_interface_M_Data, pat_tree_tmp_pkt[195:100] } ;
  assign pkt_data__h862 = { core$io_mem_interface_M_Data, 96'd0 } ;
  assign x_data__h1821 = { 32'd0, pat_tree_data_resp[171:76] } ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (!RST_N)
      begin
        hold <= `BSV_ASSIGNMENT_DELAY 1'd1;
	pat_tree_data_resp <= `BSV_ASSIGNMENT_DELAY 175'd0;
	pat_tree_pkt_ok <= `BSV_ASSIGNMENT_DELAY 1'd0;
	pat_tree_pkt_rd_ptr <= `BSV_ASSIGNMENT_DELAY 2'd0;
	pat_tree_resp_rd_ptr <= `BSV_ASSIGNMENT_DELAY 2'd0;
	pat_tree_sm_state <= `BSV_ASSIGNMENT_DELAY 3'd0;
	pat_tree_tmp_pkt <= `BSV_ASSIGNMENT_DELAY 198'd0;
      end
    else
      begin
        if (hold$EN) hold <= `BSV_ASSIGNMENT_DELAY hold$D_IN;
	if (pat_tree_data_resp$EN)
	  pat_tree_data_resp <= `BSV_ASSIGNMENT_DELAY pat_tree_data_resp$D_IN;
	if (pat_tree_pkt_ok$EN)
	  pat_tree_pkt_ok <= `BSV_ASSIGNMENT_DELAY pat_tree_pkt_ok$D_IN;
	if (pat_tree_pkt_rd_ptr$EN)
	  pat_tree_pkt_rd_ptr <= `BSV_ASSIGNMENT_DELAY
	      pat_tree_pkt_rd_ptr$D_IN;
	if (pat_tree_resp_rd_ptr$EN)
	  pat_tree_resp_rd_ptr <= `BSV_ASSIGNMENT_DELAY
	      pat_tree_resp_rd_ptr$D_IN;
	if (pat_tree_sm_state$EN)
	  pat_tree_sm_state <= `BSV_ASSIGNMENT_DELAY pat_tree_sm_state$D_IN;
	if (pat_tree_tmp_pkt$EN)
	  pat_tree_tmp_pkt <= `BSV_ASSIGNMENT_DELAY pat_tree_tmp_pkt$D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    hold = 1'h0;
    pat_tree_data_resp = 175'h2AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA;
    pat_tree_pkt_ok = 1'h0;
    pat_tree_pkt_rd_ptr = 2'h2;
    pat_tree_resp_rd_ptr = 2'h2;
    pat_tree_sm_state = 3'h2;
    pat_tree_tmp_pkt =
	198'h2AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on

  // handling of system tasks

  // synopsys translate_off
  always@(negedge CLK)
  begin
    #0;
    if (RST_N)
      if (WILL_FIRE_RL_pat_tree_incoming_read)
	$display("Handing read to addr 0x%x", core$io_mem_interface_M_Addr);
    if (RST_N)
      if (WILL_FIRE_RL_pat_tree_incoming_write)
	$display("Start write to address 0x%x D 0x%x BEN 0x%x",
		 core$io_mem_interface_M_Addr[31:4],
		 pkt_data__h862,
		 pkt_ben__h863);
    if (RST_N)
      if (WILL_FIRE_RL_pat_tree_continue_write)
	$display("Continue write, D 0x%x, BEN 0x%x",
		 pkt_data__h1182,
		 pkt_ben__h1183);
    if (RST_N)
      if (WILL_FIRE_RL_pat_tree_continue_write && pat_tree_pkt_rd_ptr == 2'd3)
	$display("Write complete, dispatching");
  end
  // synopsys translate_on
endmodule  // mkPatmos

