//
// Generated by Bluespec Compiler, version 2012.01.A (build 26572, 2012-01-17)
//
// On Tue Jan 21 11:14:18 GMT 2014
//
// Method conflict info:
// Method: bluetree_request_get
// Conflict-free: slave_put_MCmd,
// 	       slave_put_MAddr,
// 	       slave_put_MData,
// 	       slave_put_MDataValid,
// 	       slave_put_MBE,
// 	       slave_get_SResp,
// 	       slave_get_SData,
// 	       slave_get_SCmdAccept,
// 	       slave_get_SDataAccept
// Sequenced before: bluetree_response_put
// Conflicts: bluetree_request_get
//
// Method: bluetree_response_put
// Conflict-free: slave_put_MCmd,
// 	       slave_put_MAddr,
// 	       slave_put_MData,
// 	       slave_put_MDataValid,
// 	       slave_put_MBE,
// 	       slave_get_SResp,
// 	       slave_get_SData,
// 	       slave_get_SCmdAccept,
// 	       slave_get_SDataAccept
// Sequenced after: bluetree_request_get
// Conflicts: bluetree_response_put
//
// Method: slave_put_MCmd
// Conflict-free: bluetree_request_get,
// 	       bluetree_response_put,
// 	       slave_put_MAddr,
// 	       slave_put_MData,
// 	       slave_put_MDataValid,
// 	       slave_put_MBE,
// 	       slave_get_SResp,
// 	       slave_get_SData
// Sequenced before (restricted): slave_get_SCmdAccept, slave_get_SDataAccept
// Conflicts: slave_put_MCmd
//
// Method: slave_put_MAddr
// Conflict-free: bluetree_request_get,
// 	       bluetree_response_put,
// 	       slave_put_MCmd,
// 	       slave_put_MData,
// 	       slave_put_MDataValid,
// 	       slave_put_MBE,
// 	       slave_get_SResp,
// 	       slave_get_SData
// Sequenced before (restricted): slave_get_SCmdAccept, slave_get_SDataAccept
// Conflicts: slave_put_MAddr
//
// Method: slave_put_MData
// Conflict-free: bluetree_request_get,
// 	       bluetree_response_put,
// 	       slave_put_MCmd,
// 	       slave_put_MAddr,
// 	       slave_put_MDataValid,
// 	       slave_put_MBE,
// 	       slave_get_SResp,
// 	       slave_get_SData
// Sequenced before (restricted): slave_get_SCmdAccept, slave_get_SDataAccept
// Conflicts: slave_put_MData
//
// Method: slave_put_MDataValid
// Conflict-free: bluetree_request_get,
// 	       bluetree_response_put,
// 	       slave_put_MCmd,
// 	       slave_put_MAddr,
// 	       slave_put_MData,
// 	       slave_put_MBE,
// 	       slave_get_SResp,
// 	       slave_get_SData
// Sequenced before (restricted): slave_get_SCmdAccept, slave_get_SDataAccept
// Conflicts: slave_put_MDataValid
//
// Method: slave_put_MBE
// Conflict-free: bluetree_request_get,
// 	       bluetree_response_put,
// 	       slave_put_MCmd,
// 	       slave_put_MAddr,
// 	       slave_put_MData,
// 	       slave_put_MDataValid,
// 	       slave_get_SResp,
// 	       slave_get_SData
// Sequenced before (restricted): slave_get_SCmdAccept, slave_get_SDataAccept
// Conflicts: slave_put_MBE
//
// Method: slave_get_SResp
// Conflict-free: bluetree_request_get,
// 	       bluetree_response_put,
// 	       slave_put_MCmd,
// 	       slave_put_MAddr,
// 	       slave_put_MData,
// 	       slave_put_MDataValid,
// 	       slave_put_MBE,
// 	       slave_get_SResp,
// 	       slave_get_SData,
// 	       slave_get_SCmdAccept,
// 	       slave_get_SDataAccept
//
// Method: slave_get_SData
// Conflict-free: bluetree_request_get,
// 	       bluetree_response_put,
// 	       slave_put_MCmd,
// 	       slave_put_MAddr,
// 	       slave_put_MData,
// 	       slave_put_MDataValid,
// 	       slave_put_MBE,
// 	       slave_get_SResp,
// 	       slave_get_SData,
// 	       slave_get_SCmdAccept,
// 	       slave_get_SDataAccept
//
// Method: slave_get_SCmdAccept
// Conflict-free: bluetree_request_get,
// 	       bluetree_response_put,
// 	       slave_get_SResp,
// 	       slave_get_SData,
// 	       slave_get_SCmdAccept,
// 	       slave_get_SDataAccept
// Sequenced after (restricted): slave_put_MCmd,
// 			      slave_put_MAddr,
// 			      slave_put_MData,
// 			      slave_put_MDataValid,
// 			      slave_put_MBE
//
// Method: slave_get_SDataAccept
// Conflict-free: bluetree_request_get,
// 	       bluetree_response_put,
// 	       slave_get_SResp,
// 	       slave_get_SData,
// 	       slave_get_SCmdAccept,
// 	       slave_get_SDataAccept
// Sequenced after (restricted): slave_put_MCmd,
// 			      slave_put_MAddr,
// 			      slave_put_MData,
// 			      slave_put_MDataValid,
// 			      slave_put_MBE
//
//
// Ports:
// Name                         I/O  size props
// bluetree_request_get           O   198 reg
// RDY_bluetree_request_get       O     1
// RDY_bluetree_response_put      O     1
// slave_get_SResp                O     2
// slave_get_SData                O    32
// slave_get_SCmdAccept           O     1
// slave_get_SDataAccept          O     1
// CLK                            I     1 clock
// RST_N                          I     1 reset
// bluetree_response_put          I   175
// slave_put_MCmd_x               I     3
// slave_put_MAddr_x              I    32
// slave_put_MData_x              I    32
// slave_put_MBE_x                I     4
// EN_bluetree_response_put       I     1
// EN_slave_put_MDataValid        I     1
// EN_bluetree_request_get        I     1
//
// Combinational paths from inputs to outputs:
//   (slave_put_MCmd_x, EN_slave_put_MDataValid) -> slave_get_SCmdAccept
//   (slave_put_MCmd_x, EN_slave_put_MDataValid) -> slave_get_SDataAccept
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
`define BSV_ASSIGNMENT_DELAY
`endif

module mkBluetreeToOCP(CLK,
		       RST_N,

		       EN_bluetree_request_get,
		       bluetree_request_get,
		       RDY_bluetree_request_get,

		       bluetree_response_put,
		       EN_bluetree_response_put,
		       RDY_bluetree_response_put,

		       slave_put_MCmd_x,

		       slave_put_MAddr_x,

		       slave_put_MData_x,

		       EN_slave_put_MDataValid,

		       slave_put_MBE_x,

		       slave_get_SResp,

		       slave_get_SData,

		       slave_get_SCmdAccept,

		       slave_get_SDataAccept);
  input  CLK;
  input  RST_N;

  // actionvalue method bluetree_request_get
  input  EN_bluetree_request_get;
  output [197 : 0] bluetree_request_get;
  output RDY_bluetree_request_get;

  // action method bluetree_response_put
  input  [174 : 0] bluetree_response_put;
  input  EN_bluetree_response_put;
  output RDY_bluetree_response_put;

  // action method slave_put_MCmd
  input  [2 : 0] slave_put_MCmd_x;

  // action method slave_put_MAddr
  input  [31 : 0] slave_put_MAddr_x;

  // action method slave_put_MData
  input  [31 : 0] slave_put_MData_x;

  // action method slave_put_MDataValid
  input  EN_slave_put_MDataValid;

  // action method slave_put_MBE
  input  [3 : 0] slave_put_MBE_x;

  // value method slave_get_SResp
  output [1 : 0] slave_get_SResp;

  // value method slave_get_SData
  output [31 : 0] slave_get_SData;

  // value method slave_get_SCmdAccept
  output slave_get_SCmdAccept;

  // value method slave_get_SDataAccept
  output slave_get_SDataAccept;

  // signals for module outputs
  wire [197 : 0] bluetree_request_get;
  wire [31 : 0] slave_get_SData;
  wire [1 : 0] slave_get_SResp;
  wire RDY_bluetree_request_get,
       RDY_bluetree_response_put,
       slave_get_SCmdAccept,
       slave_get_SDataAccept;

  // inlined wires
  wire [31 : 0] bridge_s_data$wget;
  wire [1 : 0] bridge_s_resp$wget;

  // register client_data_resp
  reg [174 : 0] client_data_resp;
  wire [174 : 0] client_data_resp$D_IN;
  wire client_data_resp$EN;

  // register client_pkt_ok
  reg client_pkt_ok;
  wire client_pkt_ok$D_IN, client_pkt_ok$EN;

  // register client_pkt_rd_ptr
  reg [1 : 0] client_pkt_rd_ptr;
  wire [1 : 0] client_pkt_rd_ptr$D_IN;
  wire client_pkt_rd_ptr$EN;

  // register client_resp_rd_ptr
  reg [1 : 0] client_resp_rd_ptr;
  wire [1 : 0] client_resp_rd_ptr$D_IN;
  wire client_resp_rd_ptr$EN;

  // register client_sm_state
  reg [2 : 0] client_sm_state;
  reg [2 : 0] client_sm_state$D_IN;
  wire client_sm_state$EN;

  // register client_tmp_pkt
  reg [197 : 0] client_tmp_pkt;
  reg [197 : 0] client_tmp_pkt$D_IN;
  wire client_tmp_pkt$EN;

  // rule scheduling signals
  wire WILL_FIRE_RL_client_continue_write,
       WILL_FIRE_RL_client_incoming_read,
       WILL_FIRE_RL_client_incoming_write;

  // inputs to muxes for submodule ports
  wire [197 : 0] MUX_client_tmp_pkt$write_1__VAL_1,
		 MUX_client_tmp_pkt$write_1__VAL_2,
		 MUX_client_tmp_pkt$write_1__VAL_3;
  wire [174 : 0] MUX_client_data_resp$write_1__VAL_1;
  wire [31 : 0] MUX_bridge_s_data$wset_1__VAL_1;
  wire [1 : 0] MUX_client_pkt_rd_ptr$write_1__VAL_1;
  wire MUX_client_data_resp$write_1__SEL_1,
       MUX_client_pkt_ok$write_1__SEL_1,
       MUX_client_sm_state$write_1__SEL_1;

  // remaining internal signals
  wire [127 : 0] pkt_data__h1189, pkt_data__h1510, x_data__h2142;
  wire [15 : 0] pkt_ben__h1190, pkt_ben__h1511;

  // actionvalue method bluetree_request_get
  assign bluetree_request_get = client_tmp_pkt ;
  assign RDY_bluetree_request_get = client_pkt_ok && client_sm_state == 3'd3 ;

  // action method bluetree_response_put
  assign RDY_bluetree_response_put = client_sm_state == 3'd3 ;

  // value method slave_get_SResp
  assign slave_get_SResp = bridge_s_resp$wget ;

  // value method slave_get_SData
  assign slave_get_SData = bridge_s_data$wget ;

  // value method slave_get_SCmdAccept
  assign slave_get_SCmdAccept =
	     WILL_FIRE_RL_client_incoming_write ||
	     WILL_FIRE_RL_client_incoming_read ;

  // value method slave_get_SDataAccept
  assign slave_get_SDataAccept =
	     WILL_FIRE_RL_client_continue_write ||
	     WILL_FIRE_RL_client_incoming_write ;

  // rule RL_client_incoming_read
  assign WILL_FIRE_RL_client_incoming_read =
	     client_sm_state == 3'd0 && slave_put_MCmd_x == 3'd2 ;

  // rule RL_client_incoming_write
  assign WILL_FIRE_RL_client_incoming_write =
	     client_sm_state == 3'd0 && slave_put_MCmd_x == 3'd1 &&
	     EN_slave_put_MDataValid ;

  // rule RL_client_continue_write
  assign WILL_FIRE_RL_client_continue_write =
	     client_sm_state == 3'd2 && EN_slave_put_MDataValid &&
	     !client_pkt_ok ;

  // inputs to muxes for submodule ports
  assign MUX_client_data_resp$write_1__SEL_1 =
	     client_sm_state == 3'd4 && client_data_resp[174:172] != 3'd3 ;
  assign MUX_client_pkt_ok$write_1__SEL_1 =
	     WILL_FIRE_RL_client_continue_write && client_pkt_rd_ptr == 2'd3 ;
  assign MUX_client_sm_state$write_1__SEL_1 =
	     client_sm_state == 3'd4 &&
	     (client_data_resp[174:172] == 3'd3 ||
	      client_resp_rd_ptr == 2'd3) ;
  assign MUX_bridge_s_data$wset_1__VAL_1 =
	     (client_data_resp[174:172] == 3'd3) ?
	       32'd0 :
	       client_data_resp[75:44] ;
  assign MUX_client_data_resp$write_1__VAL_1 =
	     { client_data_resp[174:172],
	       x_data__h2142,
	       client_data_resp[43:0] } ;
  assign MUX_client_pkt_rd_ptr$write_1__VAL_1 =
	     (client_pkt_rd_ptr == 2'd3) ? 2'd0 : client_pkt_rd_ptr + 2'd1 ;
  assign MUX_client_tmp_pkt$write_1__VAL_1 =
	     { 146'd0, slave_put_MAddr_x[31:4], 24'd0 } ;
  assign MUX_client_tmp_pkt$write_1__VAL_2 =
	     { 2'd0,
	       pkt_data__h1189,
	       pkt_ben__h1190,
	       slave_put_MAddr_x[31:4],
	       24'd0 } ;
  assign MUX_client_tmp_pkt$write_1__VAL_3 =
	     { client_tmp_pkt[197:196],
	       pkt_data__h1510,
	       pkt_ben__h1511,
	       client_tmp_pkt[51:0] } ;

  // inlined wires
  assign bridge_s_resp$wget = (client_sm_state != 3'd4) ? 2'd0 : 2'd1 ;
  assign bridge_s_data$wget =
	     (client_sm_state == 3'd4) ?
	       MUX_bridge_s_data$wset_1__VAL_1 :
	       32'd0 ;

  // register client_data_resp
  assign client_data_resp$D_IN =
	     MUX_client_data_resp$write_1__SEL_1 ?
	       MUX_client_data_resp$write_1__VAL_1 :
	       bluetree_response_put ;
  assign client_data_resp$EN =
	     client_sm_state == 3'd4 && client_data_resp[174:172] != 3'd3 ||
	     EN_bluetree_response_put ;

  // register client_pkt_ok
  assign client_pkt_ok$D_IN = !EN_bluetree_request_get ;
  assign client_pkt_ok$EN =
	     WILL_FIRE_RL_client_continue_write &&
	     client_pkt_rd_ptr == 2'd3 ||
	     EN_bluetree_request_get ||
	     WILL_FIRE_RL_client_incoming_read ;

  // register client_pkt_rd_ptr
  assign client_pkt_rd_ptr$D_IN =
	     WILL_FIRE_RL_client_continue_write ?
	       MUX_client_pkt_rd_ptr$write_1__VAL_1 :
	       2'd1 ;
  assign client_pkt_rd_ptr$EN = slave_get_SDataAccept ;

  // register client_resp_rd_ptr
  assign client_resp_rd_ptr$D_IN =
	     (client_resp_rd_ptr == 2'd3) ? 2'd0 : client_resp_rd_ptr + 2'd1 ;
  assign client_resp_rd_ptr$EN = MUX_client_data_resp$write_1__SEL_1 ;

  // register client_sm_state
  always@(MUX_client_sm_state$write_1__SEL_1 or
	  WILL_FIRE_RL_client_incoming_write or
	  MUX_client_pkt_ok$write_1__SEL_1 or
	  WILL_FIRE_RL_client_incoming_read or EN_bluetree_response_put)
  begin
    case (1'b1) // synopsys parallel_case
      MUX_client_sm_state$write_1__SEL_1: client_sm_state$D_IN = 3'd0;
      WILL_FIRE_RL_client_incoming_write: client_sm_state$D_IN = 3'd2;
      MUX_client_pkt_ok$write_1__SEL_1 || WILL_FIRE_RL_client_incoming_read:
	  client_sm_state$D_IN = 3'd3;
      EN_bluetree_response_put: client_sm_state$D_IN = 3'd4;
      default: client_sm_state$D_IN = 3'bxxx /* unspecified value */ ;
    endcase
  end
  assign client_sm_state$EN =
	     client_sm_state == 3'd4 &&
	     (client_data_resp[174:172] == 3'd3 ||
	      client_resp_rd_ptr == 2'd3) ||
	     WILL_FIRE_RL_client_continue_write &&
	     client_pkt_rd_ptr == 2'd3 ||
	     WILL_FIRE_RL_client_incoming_write ||
	     WILL_FIRE_RL_client_incoming_read ||
	     EN_bluetree_response_put ;

  // register client_tmp_pkt
  always@(WILL_FIRE_RL_client_incoming_read or
	  MUX_client_tmp_pkt$write_1__VAL_1 or
	  WILL_FIRE_RL_client_incoming_write or
	  MUX_client_tmp_pkt$write_1__VAL_2 or
	  WILL_FIRE_RL_client_continue_write or
	  MUX_client_tmp_pkt$write_1__VAL_3)
  begin
    case (1'b1) // synopsys parallel_case
      WILL_FIRE_RL_client_incoming_read:
	  client_tmp_pkt$D_IN = MUX_client_tmp_pkt$write_1__VAL_1;
      WILL_FIRE_RL_client_incoming_write:
	  client_tmp_pkt$D_IN = MUX_client_tmp_pkt$write_1__VAL_2;
      WILL_FIRE_RL_client_continue_write:
	  client_tmp_pkt$D_IN = MUX_client_tmp_pkt$write_1__VAL_3;
      default: client_tmp_pkt$D_IN =
		   198'bxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx /* unspecified value */ ;
    endcase
  end
  assign client_tmp_pkt$EN =
	     WILL_FIRE_RL_client_incoming_read ||
	     WILL_FIRE_RL_client_incoming_write ||
	     WILL_FIRE_RL_client_continue_write ;

  // remaining internal signals
  assign pkt_ben__h1190 = { slave_put_MBE_x, 12'd0 } ;
  assign pkt_ben__h1511 = { slave_put_MBE_x, client_tmp_pkt[67:56] } ;
  assign pkt_data__h1189 = { slave_put_MData_x, 96'd0 } ;
  assign pkt_data__h1510 = { slave_put_MData_x, client_tmp_pkt[195:100] } ;
  assign x_data__h2142 = { 32'd0, client_data_resp[171:76] } ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (!RST_N)
      begin
        client_data_resp <= `BSV_ASSIGNMENT_DELAY 175'd0;
	client_pkt_ok <= `BSV_ASSIGNMENT_DELAY 1'd0;
	client_pkt_rd_ptr <= `BSV_ASSIGNMENT_DELAY 2'd0;
	client_resp_rd_ptr <= `BSV_ASSIGNMENT_DELAY 2'd0;
	client_sm_state <= `BSV_ASSIGNMENT_DELAY 3'd0;
	client_tmp_pkt <= `BSV_ASSIGNMENT_DELAY 198'd0;
      end
    else
      begin
        if (client_data_resp$EN)
	  client_data_resp <= `BSV_ASSIGNMENT_DELAY client_data_resp$D_IN;
	if (client_pkt_ok$EN)
	  client_pkt_ok <= `BSV_ASSIGNMENT_DELAY client_pkt_ok$D_IN;
	if (client_pkt_rd_ptr$EN)
	  client_pkt_rd_ptr <= `BSV_ASSIGNMENT_DELAY client_pkt_rd_ptr$D_IN;
	if (client_resp_rd_ptr$EN)
	  client_resp_rd_ptr <= `BSV_ASSIGNMENT_DELAY client_resp_rd_ptr$D_IN;
	if (client_sm_state$EN)
	  client_sm_state <= `BSV_ASSIGNMENT_DELAY client_sm_state$D_IN;
	if (client_tmp_pkt$EN)
	  client_tmp_pkt <= `BSV_ASSIGNMENT_DELAY client_tmp_pkt$D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    client_data_resp = 175'h2AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA;
    client_pkt_ok = 1'h0;
    client_pkt_rd_ptr = 2'h2;
    client_resp_rd_ptr = 2'h2;
    client_sm_state = 3'h2;
    client_tmp_pkt = 198'h2AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on

  // handling of system tasks

  // synopsys translate_off
  always@(negedge CLK)
  begin
    #0;
    if (RST_N)
      if (WILL_FIRE_RL_client_incoming_read)
	$display("Handing read to addr 0x%x", slave_put_MAddr_x);
    if (RST_N)
      if (WILL_FIRE_RL_client_incoming_write)
	$display("Start write to address 0x%x D 0x%x BEN 0x%x",
		 slave_put_MAddr_x[31:4],
		 pkt_data__h1189,
		 pkt_ben__h1190);
    if (RST_N)
      if (WILL_FIRE_RL_client_continue_write)
	$display("Continue write, D 0x%x, BEN 0x%x",
		 pkt_data__h1510,
		 pkt_ben__h1511);
    if (RST_N)
      if (WILL_FIRE_RL_client_continue_write && client_pkt_rd_ptr == 2'd3)
	$display("Write complete, dispatching");
  end
  // synopsys translate_on
endmodule  // mkBluetreeToOCP

