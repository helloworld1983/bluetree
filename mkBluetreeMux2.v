//
// Generated by Bluespec Compiler, version 2012.01.A (build 26572, 2012-01-17)
//
// On Tue Jan 21 11:10:23 GMT 2014
//
// Method conflict info:
// Method: client_request_get
// Conflict-free: client_response_put,
// 	       server0_request_put,
// 	       server0_response_get,
// 	       server1_request_put,
// 	       server1_response_get
// Conflicts: client_request_get
//
// Method: client_response_put
// Conflict-free: client_request_get,
// 	       server0_request_put,
// 	       server0_response_get,
// 	       server1_request_put,
// 	       server1_response_get
// Conflicts: client_response_put
//
// Method: server0_request_put
// Conflict-free: client_request_get,
// 	       client_response_put,
// 	       server0_response_get,
// 	       server1_request_put,
// 	       server1_response_get
// Conflicts: server0_request_put
//
// Method: server0_response_get
// Conflict-free: client_request_get,
// 	       client_response_put,
// 	       server0_request_put,
// 	       server1_request_put,
// 	       server1_response_get
// Conflicts: server0_response_get
//
// Method: server1_request_put
// Conflict-free: client_request_get,
// 	       client_response_put,
// 	       server0_request_put,
// 	       server0_response_get,
// 	       server1_response_get
// Conflicts: server1_request_put
//
// Method: server1_response_get
// Conflict-free: client_request_get,
// 	       client_response_put,
// 	       server0_request_put,
// 	       server0_response_get,
// 	       server1_request_put
// Conflicts: server1_response_get
//
//
// Ports:
// Name                         I/O  size props
// client_request_get             O   198 reg
// RDY_client_request_get         O     1 reg
// RDY_client_response_put        O     1
// RDY_server0_request_put        O     1 reg
// server0_response_get           O   175 reg
// RDY_server0_response_get       O     1 reg
// RDY_server1_request_put        O     1 reg
// server1_response_get           O   175 reg
// RDY_server1_response_get       O     1 reg
// CLK                            I     1 clock
// RST_N                          I     1 reset
// client_response_put            I   175
// server0_request_put            I   198 reg
// server1_request_put            I   198 reg
// EN_client_response_put         I     1
// EN_server0_request_put         I     1
// EN_server1_request_put         I     1
// EN_client_request_get          I     1
// EN_server0_response_get        I     1
// EN_server1_response_get        I     1
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
`define BSV_ASSIGNMENT_DELAY
`endif

module mkBluetreeMux2(CLK,
		      RST_N,

		      EN_client_request_get,
		      client_request_get,
		      RDY_client_request_get,

		      client_response_put,
		      EN_client_response_put,
		      RDY_client_response_put,

		      server0_request_put,
		      EN_server0_request_put,
		      RDY_server0_request_put,

		      EN_server0_response_get,
		      server0_response_get,
		      RDY_server0_response_get,

		      server1_request_put,
		      EN_server1_request_put,
		      RDY_server1_request_put,

		      EN_server1_response_get,
		      server1_response_get,
		      RDY_server1_response_get);
  input  CLK;
  input  RST_N;

  // actionvalue method client_request_get
  input  EN_client_request_get;
  output [197 : 0] client_request_get;
  output RDY_client_request_get;

  // action method client_response_put
  input  [174 : 0] client_response_put;
  input  EN_client_response_put;
  output RDY_client_response_put;

  // action method server0_request_put
  input  [197 : 0] server0_request_put;
  input  EN_server0_request_put;
  output RDY_server0_request_put;

  // actionvalue method server0_response_get
  input  EN_server0_response_get;
  output [174 : 0] server0_response_get;
  output RDY_server0_response_get;

  // action method server1_request_put
  input  [197 : 0] server1_request_put;
  input  EN_server1_request_put;
  output RDY_server1_request_put;

  // actionvalue method server1_response_get
  input  EN_server1_response_get;
  output [174 : 0] server1_response_get;
  output RDY_server1_response_get;

  // signals for module outputs
  wire [197 : 0] client_request_get;
  wire [174 : 0] server0_response_get, server1_response_get;
  wire RDY_client_request_get,
       RDY_client_response_put,
       RDY_server0_request_put,
       RDY_server0_response_get,
       RDY_server1_request_put,
       RDY_server1_response_get;

  // inlined wires
  wire set_down_valid_0$whas, set_down_valid_1$whas;

  // register down
  reg [174 : 0] down;
  wire [174 : 0] down$D_IN;
  wire down$EN;

  // register down_valid_0
  reg down_valid_0;
  wire down_valid_0$D_IN, down_valid_0$EN;

  // register down_valid_1
  reg down_valid_1;
  wire down_valid_1$D_IN, down_valid_1$EN;

  // register ticks
  reg [31 : 0] ticks;
  wire [31 : 0] ticks$D_IN;
  wire ticks$EN;

  // ports of submodule in0
  wire [197 : 0] in0$D_IN, in0$D_OUT;
  wire in0$CLR, in0$DEQ, in0$EMPTY_N, in0$ENQ, in0$FULL_N;

  // ports of submodule in1
  wire [197 : 0] in1$D_IN, in1$D_OUT;
  wire in1$CLR, in1$DEQ, in1$EMPTY_N, in1$ENQ, in1$FULL_N;

  // ports of submodule up
  wire [197 : 0] up$D_IN, up$D_OUT;
  wire up$CLR, up$DEQ, up$EMPTY_N, up$ENQ, up$FULL_N;

  // rule scheduling signals
  wire CAN_FIRE_RL_relay_up_1, WILL_FIRE_RL_relay_up_0;

  // inputs to muxes for submodule ports
  wire [197 : 0] MUX_up$enq_1__VAL_1, MUX_up$enq_1__VAL_2;
  wire MUX_up$enq_1__SEL_2;

  // remaining internal signals
  wire [7 : 0] x__h1013, x__h1543, x__h871, y_avValue_cpu_id__h1454;

  // actionvalue method client_request_get
  assign client_request_get = up$D_OUT ;
  assign RDY_client_request_get = up$EMPTY_N ;

  // action method client_response_put
  assign RDY_client_response_put = !down_valid_0 && !down_valid_1 ;

  // action method server0_request_put
  assign RDY_server0_request_put = in0$FULL_N ;

  // actionvalue method server0_response_get
  assign server0_response_get = down ;
  assign RDY_server0_response_get = down_valid_0 ;

  // action method server1_request_put
  assign RDY_server1_request_put = in1$FULL_N ;

  // actionvalue method server1_response_get
  assign server1_response_get = down ;
  assign RDY_server1_response_get = down_valid_1 ;

  // submodule in0
  FIFO2 #(.width(32'd198), .guarded(32'd1)) in0(.RST_N(RST_N),
						.CLK(CLK),
						.D_IN(in0$D_IN),
						.ENQ(in0$ENQ),
						.DEQ(in0$DEQ),
						.CLR(in0$CLR),
						.D_OUT(in0$D_OUT),
						.FULL_N(in0$FULL_N),
						.EMPTY_N(in0$EMPTY_N));

  // submodule in1
  FIFO2 #(.width(32'd198), .guarded(32'd1)) in1(.RST_N(RST_N),
						.CLK(CLK),
						.D_IN(in1$D_IN),
						.ENQ(in1$ENQ),
						.DEQ(in1$DEQ),
						.CLR(in1$CLR),
						.D_OUT(in1$D_OUT),
						.FULL_N(in1$FULL_N),
						.EMPTY_N(in1$EMPTY_N));

  // submodule up
  FIFO2 #(.width(32'd198), .guarded(32'd1)) up(.RST_N(RST_N),
					       .CLK(CLK),
					       .D_IN(up$D_IN),
					       .ENQ(up$ENQ),
					       .DEQ(up$DEQ),
					       .CLR(up$CLR),
					       .D_OUT(up$D_OUT),
					       .FULL_N(up$FULL_N),
					       .EMPTY_N(up$EMPTY_N));

  // rule RL_relay_up_0
  assign WILL_FIRE_RL_relay_up_0 = in0$EMPTY_N && up$FULL_N ;

  // rule RL_relay_up_1
  assign CAN_FIRE_RL_relay_up_1 = up$FULL_N && in1$EMPTY_N ;

  // inputs to muxes for submodule ports
  assign MUX_up$enq_1__SEL_2 =
	     CAN_FIRE_RL_relay_up_1 && !WILL_FIRE_RL_relay_up_0 ;
  assign MUX_up$enq_1__VAL_1 =
	     { in0$D_OUT[197:16], x__h871, in0$D_OUT[7:0] } ;
  assign MUX_up$enq_1__VAL_2 =
	     { in1$D_OUT[197:16], x__h1013, in1$D_OUT[7:0] } ;

  // inlined wires
  assign set_down_valid_0$whas =
	     EN_client_response_put &&
	     (client_response_put[7:0] == 8'd255 || !client_response_put[0]) ;
  assign set_down_valid_1$whas =
	     EN_client_response_put && client_response_put[0] ;

  // register down
  assign down$D_IN = { client_response_put[174:8], x__h1543 } ;
  assign down$EN = EN_client_response_put ;

  // register down_valid_0
  assign down_valid_0$D_IN = set_down_valid_0$whas ;
  assign down_valid_0$EN = set_down_valid_0$whas || EN_server0_response_get ;

  // register down_valid_1
  assign down_valid_1$D_IN = set_down_valid_1$whas ;
  assign down_valid_1$EN = set_down_valid_1$whas || EN_server1_response_get ;

  // register ticks
  assign ticks$D_IN = ticks + 32'd1 ;
  assign ticks$EN = 1'd1 ;

  // submodule in0
  assign in0$D_IN = server0_request_put ;
  assign in0$ENQ = EN_server0_request_put ;
  assign in0$DEQ = WILL_FIRE_RL_relay_up_0 ;
  assign in0$CLR = 1'b0 ;

  // submodule in1
  assign in1$D_IN = server1_request_put ;
  assign in1$ENQ = EN_server1_request_put ;
  assign in1$DEQ = MUX_up$enq_1__SEL_2 ;
  assign in1$CLR = 1'b0 ;

  // submodule up
  assign up$D_IN =
	     WILL_FIRE_RL_relay_up_0 ?
	       MUX_up$enq_1__VAL_1 :
	       MUX_up$enq_1__VAL_2 ;
  assign up$ENQ =
	     WILL_FIRE_RL_relay_up_0 ||
	     CAN_FIRE_RL_relay_up_1 && !WILL_FIRE_RL_relay_up_0 ;
  assign up$DEQ = EN_client_request_get ;
  assign up$CLR = 1'b0 ;

  // remaining internal signals
  assign x__h1013 =
	     (in1$D_OUT[15:8] == 8'd255) ?
	       in1$D_OUT[15:8] :
	       { in1$D_OUT[14:8], 1'd1 } ;
  assign x__h1543 =
	     (client_response_put[7:0] == 8'd255) ?
	       client_response_put[7:0] :
	       y_avValue_cpu_id__h1454 ;
  assign x__h871 =
	     (in0$D_OUT[15:8] == 8'd255) ?
	       in0$D_OUT[15:8] :
	       { in0$D_OUT[14:8], 1'd0 } ;
  assign y_avValue_cpu_id__h1454 = { 1'd0, client_response_put[7:1] } ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (!RST_N)
      begin
        down <= `BSV_ASSIGNMENT_DELAY 175'd0;
	down_valid_0 <= `BSV_ASSIGNMENT_DELAY 1'd0;
	down_valid_1 <= `BSV_ASSIGNMENT_DELAY 1'd0;
	ticks <= `BSV_ASSIGNMENT_DELAY 32'd0;
      end
    else
      begin
        if (down$EN) down <= `BSV_ASSIGNMENT_DELAY down$D_IN;
	if (down_valid_0$EN)
	  down_valid_0 <= `BSV_ASSIGNMENT_DELAY down_valid_0$D_IN;
	if (down_valid_1$EN)
	  down_valid_1 <= `BSV_ASSIGNMENT_DELAY down_valid_1$D_IN;
	if (ticks$EN) ticks <= `BSV_ASSIGNMENT_DELAY ticks$D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    down = 175'h2AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA;
    down_valid_0 = 1'h0;
    down_valid_1 = 1'h0;
    ticks = 32'hAAAAAAAA;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on
endmodule  // mkBluetreeMux2

